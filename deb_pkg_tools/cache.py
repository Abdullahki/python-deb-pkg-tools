# Debian packaging tools: Caching of package metadata.
#
# Author: Peter Odding <peter@peterodding.com>
# Last Change: November 22, 2016
# URL: https://github.com/xolox/python-deb-pkg-tools

"""
Debian binary package metadata cache.

The :class:`PackageCache` class implements a persistent, multiprocess cache for
Debian binary package metadata. The cache supports the following binary package
metadata:

- The control fields of packages;
- The files installed by packages;
- The MD5, SHA1 and SHA256 sums of packages.

The package metadata cache can speed up the following functions:

- :func:`.collect_related_packages()`
- :func:`.get_packages_entry()`
- :func:`.inspect_package()`
- :func:`.inspect_package_contents()`
- :func:`.inspect_package_fields()`
- :func:`.scan_packages()`
- :func:`.update_repository()`

Because a lot of functionality in `deb-pkg-tools` uses
:func:`.inspect_package()` and its variants, the package metadata cache
almost always provides a speedup compared to recalculating metadata on demand.
The cache is especially useful when you're manipulating large package
repositories where relatively little metadata changes (which is a pretty common
use case if you're using `deb-pkg-tools` seriously).
"""

# Standard library modules.
import errno
import logging
import os

# External dependencies.
from cached_property import cached_property

# Load the fastest pickle module available to us.
try:
    import cPickle as pickle
except ImportError:
    import pickle

# Modules included in our package.
from deb_pkg_tools.package import inspect_package_contents, inspect_package_fields
from deb_pkg_tools.repo import get_packages_entry
from deb_pkg_tools.utils import makedirs, sha1

# Initialize a logger for this module.
logger = logging.getLogger(__name__)

# Instance of PackageCache, initialized on demand by get_default_cache().
default_cache_instance = None


def get_default_cache():
    """
    Load the default package cache stored inside the user's home directory.

    The location of the cache is configurable using the option
    :data:`.package_cache_directory`, however make sure you set that option
    *before* calling :func:`get_default_cache()` because the cache will be
    initialized only once.

    :returns: A :class:`PackageCache` object.
    """
    global default_cache_instance
    if default_cache_instance is None:
        from deb_pkg_tools.config import package_cache_directory
        default_cache_instance = PackageCache(directory=package_cache_directory)
    return default_cache_instance


class PackageCache(object):

    """A persistent, multi process cache for Debian binary package metadata."""

    def __init__(self, directory):
        """
        Initialize a package cache.

        :param directory: The pathname of the package cache directory (a string).
        """
        self.directory = directory
        self.identity_map = {}

    def __getitem__(self, pathname):
        """
        Get a cache entry representing a Debian binary package archive.

        :param pathname: The pathname of a Debian binary package archive (a string).
        :returns: A :class:`CachedPackage` object.
        """
        pathname = os.path.realpath(pathname)
        entry = self.identity_map.get(pathname)
        if not entry:
            entry = CachedPackage(cache=self, pathname=pathname)
            self.identity_map[pathname] = entry
        return entry

    def collect_garbage(self, force=False):
        """Not yet implemented for the new filesystem based cache."""
        logger.warning("Garbage collection for deb-pkg-tools package cache not yet implemented!")


class CachedPackage(object):

    """
    A cache entry representing a Debian binary package archive's metadata.

    The following attributes are always available:

    - :attr:`pathname`

    The following attributes are loaded on demand:

    - :attr:`control_fields`
    - :attr:`package_fields`
    - :attr:`contents`
    """

    def __init__(self, cache, pathname):
        """
        Initialize a :class:`CachedPackage` object.

        :param cache: The :class:`PackageCache` that created this object.
        :param pathname: The pathname of a Debian binary package archive (a string).
        """
        self.cache = cache
        self.pathname = pathname
        self.fingerprint = sha1(pathname.encode('UTF-8'))

    @cached_property
    def control_fields(self):
        """
        The control fields extracted from the Debian binary package archive.

        :returns: A dictionary with control fields generated by
                  :func:`.inspect_package_fields()`.
        """
        file_in_cache = self.generate_filename('control-fields')
        try:
            control_fields = self.read_from_cache(file_in_cache)
        except Exception:
            logger.debug("Failed to read control fields from cache, generating new value ..", exc_info=True)
            control_fields = inspect_package_fields(self.pathname)
            self.write_to_cache(file_in_cache, control_fields)
        return control_fields

    @cached_property
    def package_fields(self):
        """
        The control fields required in a ``Packages`` file.

        :returns: A dictionary with control fields generated by
                  :func:`.get_packages_entry()`.
        """
        file_in_cache = self.generate_filename('package-fields')
        try:
            package_fields = self.read_from_cache(file_in_cache)
        except Exception:
            logger.debug("Failed to read package fields from cache, generating new value ..", exc_info=True)
            package_fields = get_packages_entry(self.pathname)
            self.write_to_cache(file_in_cache, package_fields)
        return package_fields

    @cached_property
    def contents(self):
        """
        The contents extracted from the Debian binary package archive (a dictionary).

        :returns: A dictionary with package contents just like the one returned
                  by :func:`.inspect_package_contents()`.
        """
        file_in_cache = self.generate_filename('contents')
        try:
            contents = self.read_from_cache(file_in_cache)
        except Exception:
            logger.debug("Failed to read package contents from cache, generating new value ..", exc_info=True)
            contents = inspect_package_contents(self.pathname)
            self.write_to_cache(file_in_cache, contents)
        return contents

    def generate_filename(self, category):
        """
        Generate a filename for the cache entry in the given category.

        :param category: The type of cache entry (a string like
                         'control-fields', 'package-fields' or 'contents').
        :returns: The absolute pathname of the cache entry (a string).
        """
        return os.path.join(self.cache.directory, category, '%s.pickle' % self.fingerprint)

    def read_from_cache(self, file_in_cache):
        """
        Read a cache entry.

        :param file_in_cache: The absolute pathname of the cache entry (a string).
        :returns: The cache entry's value.
        """
        cache_last_updated = os.path.getmtime(file_in_cache)
        archive_last_updated = os.path.getmtime(self.pathname)
        if archive_last_updated > cache_last_updated:
            raise Exception("Stale cache entry!")
        with open(file_in_cache, 'rb') as handle:
            return pickle.load(handle)

    def write_to_cache(self, file_in_cache, value):
        """
        Write a cache entry.

        :param file_in_cache: The absolute pathname of the cache entry (a string).
        :param value: The value to save in the cache.
        """
        # Write the cache entry to a temporary file.
        directory, filename = os.path.split(file_in_cache)
        temporary_file = os.path.join(directory, '.%s-%i' % (filename, os.getpid()))
        try:
            # Try to write the cache entry.
            self.write_file(temporary_file, value)
        except IOError as e:
            # We may be missing the cache directory.
            if e.errno == errno.ENOENT:
                # Make sure the cache directory exists.
                makedirs(directory)
                # Try to write the cache entry again.
                self.write_file(temporary_file, value)
            else:
                # Don't swallow exceptions we can't handle.
                raise
        # Move the temporary file into place, trusting the
        # filesystem to handle this operation atomically.
        os.rename(temporary_file, file_in_cache)

    def write_file(self, filename, value):
        """Helper for :func:`write_to_cache()`."""
        with open(filename, 'wb') as handle:
            pickle.dump(value, handle)
